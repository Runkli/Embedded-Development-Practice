;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Wed Apr 21 2021
; Processor: ATmega128
; Compiler:  AVRASM (Proteus)
;====================================================================

      .include "m128def.inc"
      
;====================================================================
; DEFINITIONS
;====================================================================

;====================================================================
; VARIABLES
;====================================================================

;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================

;====================================================================
; CODE SEGMENT
;====================================================================


.equ CRC_POL = 0x35 ;110101 ; x^5 + x^4 + 0*x^3 + x^2 + x^1 1

.equ NEWRAMEND = 0x1900

.def PACKET_IN_REGISTER = R21

; MAIN BRANCH
.org 0x00
; program starts here linearly
CONF:
	; constant registers
	ldi r17, 0x00	; zero register
	ldi r18, 0xFF	; one register
	mov r1, r17
	mov r2, r18
	
	; configure ports
	ldi r16, 0x08
	sts ddrf, r16	; user input and sensor interaction
	out ddrb, r2	; ram dump output
	out ddrd, r1	; command input
	out ddre, r2	; command output

	; configure xmem mode
    ldi r16, 0x80 ; 1000 0000
    out mcucr, r16

	; Y will be used as memory pointer
	ldi yl, 0x00
	ldi yh, 0x01
	
	rjmp INIT
	
PRE_INIT:
   ldi r16, 0x00
   sts portf, r16

INIT: ; Transmits a Reset request in a Packet_Out to reset the remote sensor state

	; Initialize stack pointer, since no flow reaches before here, stack pointer is in INIT
	ldi r16,low(NEWRAMEND)
	out spl, r16
	ldi r16,high(NEWRAMEND)
	out sph, r16


	;-----------
	ldi r20, 0x00	; reset request
    call CRC3
	call TRANSMIT

	push r20

PRE_SERVICE_READOUT:
	call SERVICE_READOUT
	
	; start == 1?
	sbis pinf, 2	; if bit 2 in io register is cleard, continue
	;no
	rjmp PRE_INIT
	
	;yes
	ldi r16, 0x08
	sts portf, r16 ; assert ready
	
	; receive == 1?
	sbis pinf, 4	; if bit 4 in io register is set, continue
	;no
	rjmp PRE_SERVICE_READOUT
	;yes
	; receive == 0?
POLL_RECV:
	sbic pinf, 4	; if bit 4 in io register is cleard, continue
	;no
	rjmp POLL_RECV
	;yes
	sts portf, r1 ; portf = 0
	in PACKET_IN_REGISTER, PIND

	; Packet_in commmand type? (if bit 7 == 0, it is command)
	sbrc PACKET_IN_REGISTER, 7
	; no
	rjmp TREAT_DATA ; first horizontal branch
	; yes (command)

	;tos has data packet?
	; load tos to register
	pop r16
	push r16
	sbrs r16, 7 ; if bit 7 == 1, it is a data packet (yes)
	;no
	rjmp CRC_CHECK3_PATH ; second horizontal branch
	;yes
	call CRC_CHECK11 ; expects return on r24
	cpi r24, 0xFF
	;true
	breq LOG_REQUEST_PATH
	;false (fail)
	pop r16
PRE_REPEAT_REQUEST:
	call REPEAT_REQUEST
	rjmp PRE_SERVICE_READOUT
	;END

TREAT_DATA: ; (HORIZONTAL BRANCH)
	; stack empty? (if sp == ramend)
	call IS_STACK_EMPTY
	breq skip_TD
	;no
	pop r16
skip_TD:
	;yes
	push PACKET_IN_REGISTER
	rjmp PRE_SERVICE_READOUT

CRC_CHECK3_PATH:
	call CRC_CHECK3 ; expects return on r24
	mov r24, r20
	cpi r24, 0xFF
	breq check3_pass
	rjmp PRE_REPEAT_REQUEST

	check3_pass:
	; acknowledge in packet_in?
	mov r16, PACKET_IN_REGISTER
	andi r16, 0x60 ; mask it 0110 0000
	cpi r16, 0x40 ;equal to 0100 0000 (acknowledge)?
	;no
	brne THIRD_H_BRANCH
	;yes
	;stack empty? (if stack == newramend)
	call IS_STACK_EMPTY
	;yes
	breq PRE_SERVICE_READOUT
	;no
	pop r16
	rjmp PRE_SERVICE_READOUT

THIRD_H_BRANCH:
	;repeat?
	mov r16, PACKET_IN_REGISTER
	andi r16, 0x60
	cpi r16, 0x60 ;repeat? 0110 0000
	;no
	brne PRE_SERVICE_READOUT
	;yes
	;stack emtpy?
	call IS_STACK_EMPTY
	;yes
	breq PRE_SERVICE_READOUT
	;no
PRE_RETRANSMIT:
	pop r20
	call TRANSMIT
	rjmp PRE_SERVICE_READOUT

LOG_REQUEST_PATH:
	mov r16, PACKET_IN_REGISTER
	andi r16, 0x60
	cpi r16, 0x20;log request?
	;no
	breq LOG
	rjmp INIT
	;yes
LOG:
	pop r16
	mov r18, r16
	andi r18, 0x1F
	st Y+, r18 ; 0x100 -> 0x101, 0x10f
	call CHECK_MEM_POINTER
	ldi r20, 0x40 ; TOS <- acknowledge 0100 0000
	call CRC3
	push r20
	rjmp PRE_RETRANSMIT

;---- custom subroutines ----
CHECK_MEM_POINTER:
	in r16, spl
	in r17, sph
	;if y < sp, don't reset y
	cp yl, r16
	cpc yh, r17
	brlo skip
	ldi yl, low(0x100)
	ldi yh, high(0x100)
	skip:
	ret

IS_STACK_EMPTY: ; sets the z using cp
	ldi r16, LOW(newramend - 0x02)
	in r17, spl
	cp r17, r16
	ldi r16, HIGH(newramend - 0x02)
	in r17, sph
	cpc r17, r16
	ret

WAIT_ONE_SECOND:
	push r16
	push r17
	push r18

	ldi r16, 60
	loop1:
		dec r16 ; 1c
		ldi r17, 0xFF ; 1c
		loop2:
			dec r17
			ldi r18, 0x0F
			loop3:
			   dec r18
			   cpse r18, r1
			   rjmp loop3
			cpse r17, r1
			rjmp loop2
		cpse r16, r1 ; 1c
		rjmp loop1 ; 1c

	pop r18
	pop r17
	pop r16
	ret

;---- subroutines specified in prompt ----
TRANSMIT: ; transmits r20 to packet_out
	out porte, r20
	ret

REPEAT_REQUEST:
	push r20
	ldi r20, 0x60 
	call CRC3
	call TRANSMIT
	pop r20
	ret

SERVICE_READOUT:
	push r16

	sbic pinf, 0
	rjmp start_mem_dump
	
	sbic pinf, 1
	rjmp transmit_last_entry

	pop r16
	ret

	start_mem_dump:
		push r20
		ldi xl, low(0x100)
		ldi xh, high(0x100)
		;while x < y
		mem_dump_loop:
			cp xl, yl
			cpc xh, yh
			breq end
			; do
			ld r20, X+
			out portb, r20
			call WAIT_ONE_SECOND
			ldi r20, 0x00
			out portb, r20
			rjmp mem_dump_loop

	transmit_last_entry:
		push r20
		mov xl, yl
		mov xh, yh
		sbiw X, 1
		ld r20, X
		out portb, r20
	        call WAIT_ONE_SECOND
	        ldi r20, 0x00
	        out portb, r20
	end:
		pop r20
		pop r16
		ret

CRC3:
	// Modulo 2 example
	//11100000 110101
	//111000  / 110101 = 1, xor = 001101
	// 11010  / 110101 = 0
	// 110100 / 110101 = 1, xor = 000001
	// if size(packet) == size(code)
//		xor(packet,code)
//	 else
//		left_shift_logical(packet)
	
	;pop r20
	push r16
	push r17
	push r21
	
.def packet = r20
.def reference = r21
.def code = r16
.def compare = r17

	mov reference, packet
	; Packet_Out <- Reset Req. assume Packet_Out is in arbitrary register

	; r20 = 1110 0000
	lsr packet
	lsr packet ; right shift twice to align with generator code
	ldi code, CRC_POL	; load CRC generator code
	mov compare, code

	cpi packet, 0x20
	brlo s1
	eor packet,code
s1:
	lsl packet
	cpi packet, 0x20
	brlo s2
	eor packet,code
s2:
	lsl packet
	cpi packet, 0x20
	brlo cont
	eor packet,code
cont:
	or packet, reference
	pop r21
	pop r17
	pop r16
	;push r20
.undef packet
.undef reference
.undef code
.undef compare
	ret

CRC_CHECK3:
	.def original_packet=r21
	.def packet = r20
	mov packet, original_packet
	rcall CRC3 ; reads and writes to r20
	cp packet, original_packet
	breq CRC_CHECK3_pass	; if they are equal, store 0xFF (1, true) return value to r16
	ldi r20, 0x00	; if not true, then store 0, false in r16
	rjmp CRC_CHECK3_finish
CRC_CHECK3_pass:
	ldi r20, 0xFF	; store true
CRC_CHECK3_finish:	
	ret ; returns true or false in r20 (stand)


ldi r16, 0x9F
push r16
ldi r21, 0x2E
call CRC_CHECK11


CRC_CHECK11: ; push address of caller
	.def data_packet = r23
	.def command_packet = r21
	;ldi data_packet, 0xE0 // 11100000
	;ldi command_packet, 0xE0
	pop r26
	pop r27
	pop data_packet
	mov r30, data_packet
	clc
	.def code = r19
	.def org_com = r22
	//.def org_dat = r23
	.def temp = r24
	mov org_com, command_packet // store the packet with the crc code
	//mov org_dat, data_packet
	//pop data_packet // take the data from the top of the stack
	andi command_packet, 0xE0 // 11100000
	ldi code, CRC_POL
	// packet DDDDDDDD
	//mov temp, org_dat
	mov temp, data_packet
	ldi r25, 0x03
	and temp, r25
	// temp   000000DD
	ror temp
	ror temp
	ror temp
	// temp   DD000000
	lsr data_packet
	lsr data_packet
	// shift from the right inwards until whole packet has been xor'd
	// packet XXDDDDDD
	cpi data_packet, 0x20
	brlo ss1
	eor data_packet, code
ss1:
	lsl temp
	rol data_packet
	// packet XDDDDDDD
	cpi data_packet, 0x20
	brlo ss2
	eor data_packet, code
ss2:
	lsl temp
	rol data_packet
	// packet DDDDDDDD
	cpi data_packet, 0x20
	brlo ss3
	eor data_packet, code
ss3:
	lsl command_packet
	rol data_packet
	// packet DDDDDDDC
	cpi data_packet, 0x20
	brlo s4
	eor data_packet, code
s4:
	lsl command_packet
	rol data_packet
	// packet DDDDDDCC
	cpi data_packet, 0x20
	brlo s5
	eor data_packet, code
s5:
	lsl command_packet
	rol data_packet
	// packet DDDDDCCC
	cpi data_packet, 0x20
	brlo s6
	eor data_packet, code
s6:
	lsl command_packet
	rol data_packet
	// packet DDDDCCCC
	// 001001110
	cpi data_packet, 0x20
	brlo s7
	eor data_packet, code
s7:
	lsl command_packet
	rol data_packet
	// packet DDDCCCCC
	cpi data_packet, 0x20
	brlo s8
	eor data_packet, code
s8:
	lsl command_packet
	rol data_packet
	// packet DDCCCCCC
	cpi data_packet, 0x20
	brlo s9
	eor data_packet, code
s9:
	lsl command_packet
	rol data_packet
	// packet DCCCCCCC
	cpi data_packet, 0x20
	brlo s10
	eor data_packet, code
s10:
	lsl command_packet
	rol data_packet
	// packet CCCCCCCC
	cpi data_packet, 0x20
	brlo s11
	eor data_packet, code
s11:
	// Data packet now holds remainder, 5 bits long
	mov command_packet, org_com // check the CRC5 bits
	andi command_packet, 0x1F // 0b00011111
	ldi r24, 0x00
	cp data_packet, command_packet

	mov command_packet, org_com
	breq CRC_CHECK11_pass
	rjmp CRC_CHECK11_finish
CRC_CHECK11_pass:
	ldi r24, 0xFF
CRC_CHECK11_finish:	
	.undef data_packet
	.undef command_packet
	.undef code
	.undef org_com
	.undef temp

	push r30

	push r27
	push r26
	ret

;====================================================================